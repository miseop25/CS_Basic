# 위상정렬 (Topology Sort)

## 위상정렬이란? 

    '순서가 정해져 있는 작업'을 차례로 실행할때 그 순서를 결정해 주기 위하여 사용하는 알고리즘입니다.

'순서가 정해져 있는 작업'은 다음과 같은 그래프를 의미합니다.    

![스크린샷 2020-09-02 오후 9 12 38](https://user-images.githubusercontent.com/44546283/91979665-0fbee200-ed61-11ea-8249-17fcf0f6b599.png)

위 그래프를 보면 1에서 3을 바로 실행 할 수 없고 반듯이 2를 거치고 난 이후에 3을 수행 할 수 있습니다.   
이러한 그래프는 위상 정렬을 통해서 작업의 순서를 확인할 수 있습니다. 아래는 위 그래프를 위상정렬한 결과 입니다.

![스크린샷 2020-09-02 오후 9 21 22](https://user-images.githubusercontent.com/44546283/91980473-46492c80-ed62-11ea-9529-2c1a27b83433.png)

정렬한 결과가 하나가 아닙니다. 이처럼 위상정렬은 여러개의 답이 존재할 수 있습니다.  

이러한 위상정렬을 실시하려면 한가지 조건이 필요합니다.  

    정렬할 그래프는 DAG(Directed Acyclic Graph)이여야만 한다. 

DAG는 사이클이 발생하지 않는 그래프입니다. 즉 순환이 없는 구조여야 합니다.  
만약 사이클이 생긴다면 순서가 없어지기 때문입니다.   

## 위상정렬 구현하기  

위상정렬을 수행하는 알고리즘은 크게 2가지 종류입니다.   

- Stack을 사용하는 알고리즘   
- Queue를 사용하는 알고리즘   

****
### Queue를 사용한 위상정렬 알고리즘  

큐를 사용한 위상정렬은 다음과 같은 방법으로 실행됩니다.  

1. 진입차수가 '0'인 정점을 큐에 Push 합니다.    
(진입차수 0 : 들어오는 간선이 없는 노드를 말합니다.)
2. 큐에서 원소를 하나 꺼내 해당 원소가 내보내는 간선을 모두 제거합니다.   
3. 간선 제거 후 진입차수가 '0'이 된 정점을 큐에 Push 합니다.
4. 큐가 빌때까지 2~3번 과정을 반복합니다.   
4.1 만약 큐가 비었는데 모든 간선을 방문하지 않았다면 DAG가 아닌 그래프입니다.(사이클이 존재)   

이러한 과정을 통해서 위상정렬을 구현할 수 있습니다.   
좀 더 높은 이해를 위해서 그림과 함께 살펴보겠습니다.   

<img src="https://user-images.githubusercontent.com/44546283/91989217-384bd980-ed6b-11ea-9f96-86ef352f7d70.png" width="700">   

먼저 초기상태에서 1을 수행한 결과 입니다. 진입차수가 0인 1을 큐에 Push해주었습니다.   

<img src="https://user-images.githubusercontent.com/44546283/91989222-3a159d00-ed6b-11ea-9987-6883338574d5.png" width="700">  

큐에 있는 것을 Pop해내고 해당하는 원소에서 나가는 간선을 모두 제거해 주었습니다.  
그 결과 2,4번의 진입차수가 0이 되어 큐에 추가되었습니다.  

<img src="https://user-images.githubusercontent.com/44546283/91989232-3bdf6080-ed6b-11ea-985b-6148556882d2.png" width="700">

큐에 있는 것을 Pop한 후 해당원소의 간선을 제거하였습니다.   
3번의 진입차수가 0이 되어 큐에 추가해 줍니다.   

이러한 과정을 큐가 빌때까지 진행해 주면 다음과 같은 결과가 나오게 됩니다.  

<img src="https://user-images.githubusercontent.com/44546283/91990456-b3fa5600-ed6c-11ea-9e98-812c30e9b819.png" width="700">

1 > 2 > 4 > 3 > 5 > 6 > 7 순으로 위상정렬된 결과를 볼 수 있습니다.  
***
### Stack을 이용한 위상정렬 알고리즘   

스택을 이용한 위상정렬은 DFS(깊이 우선 탐색)을 통해서 진행됩니다.  
즉, DFS를 알고있다면 어렵지 않게 구할 수 있습니다.   

알고리즘은 다음과 같이 진행하면 됩니다.   

1. 해당 그래프에 대한 DFS를 진행한다. 
2. 각 DFS가 끝나는 시점에 해당 노드를 스택에 쌓는다.
3. 모든 DFS가 종료되면 스택을 pop 해서 순서를 뒤집으면 위상정렬 결과가 된다.   

Queue를 이용한 위상정렬보다 간단해 보일 수 있지만 해당 그래프가 DAG인지를 판단하기는 어렵습니다.  
즉, 확실히 DAG인지 판명 된 이후에 진행해 주어야 합니다.  

***

## 위상정렬을 정리하면서   

백준 1766번 문제를 풀다가 위상정렬이 필요한 문제라 새롭게 공부하게 되었습니다.  
새로운 것을 알게되어 기분이 좋기도 하지만 아직 많이 부족하다는 생각도 듭니다.  
공부를 계속하여 누군가를 알려줄 수 있는 개발자가 되도록 노력해야겠습니다.  
글에 관한 잘못된 사실이나 추가해야 할 부분이 있다면 알려주시면 감사하겠습니다.  

>[백준 1766번](https://www.acmicpc.net/problem/1766)   
>[백준 1766번 풀이 코드](https://github.com/miseop25/Back_Jun_Code_Study/blob/3943a9e28a941b9d76414a5e7a80bd571af1ef3f/back_joon/자료구조/back_joon_1766_문제집/back_joon_1766_ver3.py)


### 참조한 자료  
> https://sonsh0824.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B3%B5%EB%B6%803-Topological-sort%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC-C   
> https://m.blog.naver.com/ndb796/221236874984   




